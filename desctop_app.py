import sys
import psutil  # psutil для получения текущего состояния ЦП, ОЗУ и ПЗУ
import sqlite3
from datetime import datetime
from PyQt5.QtCore import QTimer, QTime
from PyQt5.QtWidgets import (QApplication, QVBoxLayout, QLabel,
                             QPushButton, QLineEdit, QWidget)


class SystemMonitorApp(QWidget):  # SystemMonitorApp (наследуется от QWidget)
    def __init__(self):
        super().__init__()
        self.timer = QTimer()  # Таймер для периодического обновления данных.
        self.init_ui()        # Инициализация графического интерфейса.
        self.init_db()        # Инициализация базы данных.
        self.recording = False  # Флаг состояния записи данных.
        self.elapsed_time = 0   # Время записи в секундах (прошло времени).
        self.start_time = None  # Время начала записи

    def init_ui(self):
        self.setWindowTitle("Уровень загруженности:")  # Заголовок окна.
        self.resize(400, 300)   # Размер окна.

        self.layout = QVBoxLayout()   # Создаём пустой вертикальный макет.
        # QVBoxLayout — это класс из библиотеки PyQt, который организует
        # элементы интерфейса в столбик (вертикально). Он автоматически
        # размещает элементы один под другим и управляет их размерами.

        # Элементы интерфейса.
        self.cpu_label = QLabel("ЦП: --%")  # Метка загрузки ЦП.
        self.ram_label = QLabel("ОЗУ: --%")  # Метка загрузки ОЗУ Оперативное Запоминающее Устройство
        self.disk_label = QLabel("ПЗУ: --%") # Метка загрузки ПЗУ Постоянное Запоминающее устройство
        self.interval_label = QLabel("Задать интервал обновления (в секундах):")  # Подпись для ввода интервала обновления.
        self.interval_input = QLineEdit("1")  # Поле ввода интервала обновления (по умолчанию 1 секунда).
        self.start_button = QPushButton("Начать запись")  # Кнопка "Начать запись".
        self.stop_button = QPushButton("Остановить запись")    # Кнопка "Остановить запись".
        self.stop_button.hide()  # Прячем кнопку "Остановить", пока запись не началась.
        self.timer_label = QLabel("Время записи: 0с") # Метка таймера записи.

        # Добавление элементов в макет.
        # Каждый элемент добавляется в макет,
        # и они автоматически выстраиваются один под другим
        self.layout.addWidget(self.cpu_label)
        self.layout.addWidget(self.ram_label)
        self.layout.addWidget(self.disk_label)
        self.layout.addWidget(self.interval_label)
        self.layout.addWidget(self.interval_input)
        self.layout.addWidget(self.start_button)
        self.layout.addWidget(self.stop_button)
        self.layout.addWidget(self.timer_label)

        self.setLayout(self.layout)  # Устанавливаем макет для текущего окна (QWidget),
        # и теперь все элементы, добавленные в макет, будут отображаться в окне.

        # Связывание кнопок с их обработчиками.
        self.start_button.clicked.connect(self.start_recording)  # Нажатие "Начать запись".
        self.stop_button.clicked.connect(self.stop_recording)   # Нажатие "Остановить запись".
        # Что это делает?
        # Связывает сигнал clicked кнопки self.start_button
        # (сигнал возникает, когда кнопка нажата) с методом
        # self.start_recording.
        # Когда пользователь нажимает кнопку "Начать запись"
        # автоматически вызывается функция self.start_recording.
        # Как это работает?
        # У каждой кнопки в PyQt есть встроенные сигналы, например,
        # clicked (выдается, когда кнопка нажата).Метод connect()
        # связывает сигнал с конкретной функцией. Когда событие происходит,
        # вызывается указанная функция.

        # Связывание таймера с функцией обновления данных.
        self.timer.timeout.connect(self.update_data)
        # Что это делает?
        # Связывает сигнал timeout таймера self.timer с методом self.update_data.
        # Сигнал timeout генерируется, когда таймер достигает установленного интервала времени.
        # Каждый раз, когда таймер "тикает" (по умолчанию каждую секунду, если не указано иначе),
        # вызывается функция self.update_data.
        # Как это работает?
        # Таймер (QTimer) работает как "часы". Вы устанавливаете интервал времени
        # (например, 1000 миллисекунд или 1 секунду), и он повторно вызывает сигнал timeout.
        # Метод update_data обновляет показатели системы (CPU, RAM, Disk) и добавляет
        # данные в базу данных, если идет запись.

    def init_db(self):
        """Настройка Базы Данных."""
        self.conn = sqlite3.connect("app_monitoring_data.db")  # Подключение к SQLite базе.
        # Устанавливается соединение с базой данных SQLite, которая хранится в файле app_monitoring_data.db.
        # Если файл базы данных с таким именем не существует, он автоматически создается.
        # Объект self.conn представляет соединение с базой данных. Через него можно выполнять
        # операции, такие как создание таблиц или добавление записей.
        self.cursor = self.conn.cursor()              # Курсор для выполнения SQL-запросов.
        # Создается объект self.cursor, который используется для выполнения SQL-запросов к базе данных.
        # Курсор — это "инструмент", позволяющий отправлять команды SQL и получать результаты.
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS monitor_data (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            cpu_usage REAL,
            ram_usage REAL,
            disk_usage REAL
        )
        """)  # Отправляется SQL-запрос для создания таблицы monitor_data в базе данных.
        self.conn.commit()  # Сохранение изменений в БД.

    def update_data(self):
        """Метод update_data отвечает за получение данных о загрузке системы,
        обновление интерфейса и запись этих данных в базу данных, если
        активен режим записи.
        """
        # Используется библиотека psutil для получения данных о текущем состоянии системы
        cpu_usage = psutil.cpu_percent()             # возвращает загрузку процессора (ЦП) в процентах
        ram_usage = psutil.virtual_memory().percent  # возвращает процент использования оперативной памяти (ОЗУ)
        disk_usage = psutil.disk_usage('/').percent  # возвращает процент использования дискового пространства
                                                     # (ПЗУ) для указанного пути (в данном случае корневой диск /)
        # Обновление интерфейса
        # Значения загрузки системы обновляются в виджетах (метках) пользовательского интерфейса
        # Метод setText() устанавливает текст для соответствующих меток
        self.cpu_label.setText(f"ЦП: {cpu_usage}%")  # отображает текущее значение загрузки процессора
        self.ram_label.setText(f"ОЗУ: {ram_usage}%")  # отображает текущее значение загрузки оперативной памяти
        self.disk_label.setText(f"ПЗУ: {disk_usage}%")  # отображает текущее значение загрузки диска

        # Если идет запись:
        if self.recording:
            now = datetime.now()
            self.elapsed_time = (now - self.start_time).seconds  # Прошедшее время = сейчас - начало
            self.timer_label.setText(f"Время записи: {self.elapsed_time}с")
            # Обновляется текст метки self.timer_label, чтобы показать пользователю текущее время записи

            # Сохранение данных в базу.
            # Знаки вопроса (?) используются для передачи данных в запрос в качестве
            # параметров, чтобы избежать SQL-инъекций
            self.cursor.execute("""
                INSERT INTO monitor_data (timestamp, cpu_usage, ram_usage, disk_usage)
                VALUES (datetime('now'), ?, ?, ?)
            """, (cpu_usage, ram_usage, disk_usage))
            self.conn.commit()  # Фиксация изменений.

    def start_recording(self):
        """Функция запускает процесс записи данных о загрузке системы в базу данных."""
        self.recording = True                # Устанавливаем флаг записи в значение True,
                                             # что сигнализирует программе о начале записи данных
        self.start_time = datetime.now()  # Устанавливаем время начала записи
        self.elapsed_time = 0                # Обнуляем таймер записи, сбрасываем значение до нуля
        self.timer_label.setText("Время записи: 0с") # Обновляем метку таймера, отображающую
                                                     # время записи, обновляется на 0с
        self.start_button.hide()             # Скрываем кнопку "Начать запись", так как запись уже идет.
        self.stop_button.show()              # Показываем кнопку "Остановить запись",
                                             # чтобы пользователь мог завершить запись.
        interval = int(self.interval_input.text()) * 1000  # Значение интервала обновления (в секундах)
                                                           # считывается из текстового поля
                                                           # self.interval_input, конвертируется в число
                                                           # и умножается на 1000 для получения миллисекунд
                                                           # (требуется для таймера).
        self.timer.start(interval)           # Запуск таймера. Таймер self.timer запускается с заданным
                                             # интервалом, который определяет, как часто будет вызываться
                                             # функция update_data для обновления данных о загрузке системы.

    def stop_recording(self):
        """Функция завершает процесс записи данных."""
        self.recording = False              # Флаг self.recording устанавливается в значение False,
                                            # сигнализируя программе, что запись больше не ведется.
        self.start_button.show()            # Кнопка "Начать запись" (self.start_button) снова
                                            # становится видимой, позволяя начать новую запись.
        self.stop_button.hide()             # Скрываем кнопку "Остановить запись".
        self.timer.stop()                   # Останавливаем таймер, чтобы больше не вызывать функцию update_data.
        self.start_time = None              # Сбрасываем время начала записи
        self.timer_label.setText("Время записи: 0с")    # Метка self.timer_label, отображающая время записи,
                                                        # сбрасывается на "0c".

    def closeEvent(self, event):
        """функция вызывается автоматически при закрытии окна приложения
        и используется для выполнения необходимых действий перед завершением
        программы.
        """
        self.conn.close()  # Соединение с базой данных SQLite, созданное в self.conn,
                           # закрывается. Это важно для освобождения ресурсов и
                           # предотвращения потери данных.
        event.accept()     # Сигнализирует системе о том, что событие закрытия
                           # (closeEvent) принято, и приложение можно закрыть.

# выполняется, только если файл запускается напрямую (не импортируется как модуль)
if __name__ == "__main__":
    app = QApplication(sys.argv)    # Создание объекта приложения. Создается экземпляр
                                    # приложения QApplication, который управляет событиями
                                    # и основным циклом программы
    window = SystemMonitorApp()     # Создание экземпляра окна. Создается объект класса
                                    # SystemMonitorApp, который представляет главное окно
                                    # приложения. При этом вызывается его конструктор __init__,
                                    # где инициализируется пользовательский интерфейс и база данных.
    window.show()                   # Главное окно приложения становится видимым на экране
    sys.exit(app.exec_())           # Запуск основного цикла приложения.
                                    # Метод app.exec_() запускает главный цикл обработки
                                    # событий приложения. Этот цикл работает до тех пор,
                                    # пока окно приложения не будет закрыто.
                                    # sys.exit() завершает программу с кодом возврата, который позволяет
                                    # системе определить, успешно ли завершилось приложение.
